# Тестовое задание для NiceCode
## Как запустить?
1. pip install -r requirements.txt (Устанавливаем зависимости)
2. make migration (выполняет команду python manage.py makemigrations)
3. make migrate  (выполняет применение миграций)
4. run my_test_task/script.py (запускаем скрипт)

## Схемы
В my_test_task/dashboards хранятся PDF-файлы и файл .drawio 
в которых описана логика для связанных таблиц и логика алгоритма


## Принцип работы script.py


Функция create_entityamount: int, table: ModelBase, *args, **kwargs) создает сущности и
генерирует для них случайные значения на основе моделей

Далее скрипт создает 
1. Указанное кол-во товаров
2. Указанное кол-во складов
3. Указанное кол-во рандомных связей **склад_продукт** среди уже созданных товаров и складов, так же генерируются тарифы, максимальное кол-во товара на этом складе, и может ли он храниться на этом складе (у каждого склада могут быть только его продукты)
4. Указанное кол-во рандомных клиентов 
4. Указанное кол-во рандомных связей **клиент_продукт** среди уже созданных клиентов и товаров, так же генерируется кол-во приобретенного клиентом товара 
4. Указанное кол-во рандомных связей **клиент_склад** среди уже созданных клиентов и складов, так же генерируется дистанция от клиента склада (У каждого клиента могут быть только свои товары)
#### Функция возвращает список клиентов 
#### В моделях были переопределены и дополнены M2M связи [**склад_продукт**, **клиент_продукт**, **клиент_склад** ] т.к. 
1. тарифы
2. дистанция
3. максимальное хранимое кол-во товара для каждого склада
4. может ли конкретный товар храниться на конкретном складе или нет
5. кол-во заказанного клиентом товара
6. дистанция от склада до клиента с конкретным набором товаров 

#### по логике может храниться в БД только если действительно существует такая связь

Я считаю, что связи между таблицами должны быть именно M2M, но при таком условии невозможно для них переопределить метод **save()**. 
В связи c чем 








